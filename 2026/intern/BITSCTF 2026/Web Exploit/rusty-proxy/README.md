# 『rusty-proxy』

<img width="624" height="609" alt="image" src="https://github.com/user-attachments/assets/be11aa20-5e75-458f-941b-d91b4f0a2646" />

- [Source code]()

# 『The challenge』
we're given link for the chall and the source code.

<img width="563" height="183" alt="image" src="https://github.com/user-attachments/assets/ed7ca9bb-e8d0-495d-b7e4-87aaaff976ed" />

# 『Highlight vulnerability and parts of interesting』

So here are are the interesting part of this challenge

```rust
fn is_valid_http_version(v: &str) -> bool {
    v == "HTTP/1.0" || v == "HTTP/1.1"
}
```

From this one, we must use HTTP/1.0 or HTTP/1.1 version to use it

second one:

```rust
fn is_path_allowed(path: &str) -> bool {
    let normalized = path.to_lowercase();
    if normalized.starts_with("/admin") {
        return false;
    }
    true
}
```
and
```rust
if !is_path_allowed(&meta.path) {
            let _ = send_error(&mut write_half, "403 Forbidden", "Access denied.\n").await;
            break;
        }
```

if anything that contain `/admin` like: `http://localhost:25001/admin`, it will check the link first and detect any other `/admin` on that link.

third one:

```rust
if chunk_size == 0 {     
                loop {
                    let mut trailer = String::new();
                    let tn = client_reader.read_line(&mut trailer).await?;
                    if tn == 0 {
                        break;
                    }
                    
                    if trailer.trim_end().is_empty() {
                        backend.write_all(b"\r\n").await?;
                        break;
                    }
                    
                    
                    if let Some(cp) = trailer.find(':') {
                        let tname = &trailer[..cp];
                        if !is_valid_token(tname) {
                            return Err(tokio::io::Error::new(
                                tokio::io::ErrorKind::InvalidData,
                                "invalid trailer field-name",
                            ));
                        }
                    }
                    backend.write_all(trailer.as_bytes()).await?;
                }
                backend.flush().await?;
                break;
            }
```

This part is kinda interesting. The proxy will send it to backend and proceed if any malicious code to execute. 

and for the part of the flag:

```python
@app.route('/admin/flag')
def vault():
    return jsonify({"flag": FLAG})
```

to get the flag 
# 『Solving Challenge』
> solve by Lylera

To solve this one, we can bypass `/admin` by using `/%61dmin/flag` because it will decode it from %61 to a. 

I solve this one using this:

`curl --path-as-is http://chals.bitskrieg.in:25001/%61dmin/flag` and it show the flag.

or you can direct the link and send using `/%61dmin/flag` and get flag

# 『Flag』

```
BITSCTF{tr4il3r_p4r51n6_15_p41n_1n_7h3_4hh}
```
